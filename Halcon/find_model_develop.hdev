<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="12.0">
<procedure name="main">
<interface/>
<body>
<l>dev_close_window ()</l>
<l>dev_update_off ()</l>
<l>dev_set_draw ('margin')</l>
<c></c>
<l>model_image_path := 'D:/2 tasks/2D LiXun Test/1.bmp'</l>
<l>test_image_path := 'D:/2 tasks/2D LiXun Test'</l>
<c></c>
<l as_id="matching" as_name="Matching 01" as_grp="[1,1,1]" as_ord="2">read_image (Image, model_image_path)</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_open_window (0, 0, Width/4, Height/4, 'black', WindowHandle)</l>
<l>dev_set_color ('red')</l>
<l>dev_set_draw ('margin')</l>
<l>dev_display (Image)</l>
<l>stop ()</l>
<l>* Rows :=    [100,100,37,146,300,330,220]</l>
<l>* Columns := [100,200,320,374,200,110,20]</l>
<l>* gen_region_polygon_filled (Region, Rows, Columns)</l>
<c></c>
<l>disp_message (WindowHandle, 'Draw Model Region', 'window', 12, 12, 'black', 'true')</l>
<l>draw_rectangle1(WindowHandle, RowModel1, ColModel1, RowModel2, ColModel2)</l>
<l>gen_rectangle1(ModelRegion, RowModel1, ColModel1, RowModel2, ColModel2)</l>
<c></c>
<l>disp_message (WindowHandle, 'Draw RectUp Region', 'window', 12, 12, 'black', 'true')</l>
<l>draw_rectangle1(WindowHandle, RowRectUp1, ColRectUp1, RowRectUp2, ColRectUp2)</l>
<l>gen_rectangle1(RectUpRegion, RowRectUp1, ColRectUp1, RowRectUp2, ColRectUp2)</l>
<l>disp_message (WindowHandle, 'Draw RectLeft Region', 'window', 12, 12, 'black', 'true')</l>
<l>draw_rectangle1(WindowHandle, RowRectLeft1, ColRectLeft1, RowRectLeft2, ColRectLeft2)</l>
<l>gen_rectangle1(RectLeftRegion, RowRectLeft1, ColRectLeft1, RowRectLeft2, ColRectLeft2)</l>
<l>disp_message (WindowHandle, 'Draw Circle1 Region', 'window', 12, 12, 'black', 'true')</l>
<l>draw_circle (WindowHandle, RowCircle1, ColCircle1, RadiusCircle1)</l>
<l>gen_circle (Circle1, RowCircle1, ColCircle1, RadiusCircle1)</l>
<l>disp_message (WindowHandle, 'Draw Circle2 Region', 'window', 12, 12, 'black', 'true')</l>
<l>draw_circle (WindowHandle, RowCircle2, ColCircle2, RadiusCircle2)</l>
<l>gen_circle (Circle2, RowCircle2, ColCircle2, RadiusCircle2)</l>
<c></c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_set_color ('red')</l>
<l>dev_set_draw ('margin')</l>
<l>dev_display (Image)</l>
<l>dev_display (ModelRegion)</l>
<l>dev_set_color ('green')</l>
<l>dev_display (RectUpRegion)</l>
<l>dev_display (RectLeftRegion)</l>
<l>dev_display (Circle1)</l>
<l>dev_display (Circle2)</l>
<l>stop ()</l>
<l>Rows :=    [RowModel1,RowModel1,RowModel2,RowModel2,RowModel1]</l>
<l>Columns := [ColModel1,ColModel2,ColModel2,ColModel1,ColModel1]</l>
<l>gen_region_polygon_filled (Region, Rows, Columns)</l>
<c></c>
<l> NumLevels := 5</l>
<l> AngleStart := -180</l>
<l> AngleExtent := 360</l>
<l> AngleStep := 0.6955</l>
<l> ScaleMin := 0.96</l>
<l> ScaleMax := 1.04</l>
<l> MinContrast :=20 </l>
<l> MaxContrast := 40  </l>
<l> MinLength := 24 </l>
<c> </c>
<l> MinScore := 0.5</l>
<l> NumMatches := 1</l>
<c></c>
<l>CreateFeatureModel (Image, Rows, Columns, NumLevels, AngleStart, AngleExtent, AngleStep, ScaleMin, ScaleMax, MinContrast, MaxContrast, MinLength, ModelId, RowSource, ColumnSource, AngleSource, XldRows, XldCols, XldPointCounts)</l>
<c></c>
<l>*gen_cross_contour_xld (Cross, RowSource, ColumnSource, 16, 0.6)</l>
<l>*p := XldPointCounts</l>
<l>*add := 0</l>
<c></c>
<l>*gen_empty_obj (XldsModel)</l>
<l>*for i := 0 to |p| -1 by 1</l>
<l>*    gen_contour_polygon_xld (Contour, XldRows[add :add + p[i]-1], XldCols[add:add + p[i]-1])</l>
<l>*    add := add + p[i]</l>
<l>*    concat_obj (XldsModel, Contour, XldsModel)</l>
<l>*endfor</l>
<c></c>
<l>*rotate_image (Image, ImageRotate, 30, 'constant')</l>
<c></c>
<c></c>
<c></c>
<l>* read_shape_model ('ModelNormal.shm', ModelId)</l>
<c></c>
<l>list_image_files (test_image_path, 'bmp', [], ImageFiles)</l>
<l>for I := 0 to |ImageFiles|-1 by 1</l>
<l>    read_image (Image, ImageFiles[I])</l>
<c>    </c>
<l>    FindFeatureModel (Image, AngleStart, AngleExtent, AngleStep, ScaleMin, ScaleMax, MinScore, NumMatches, ModelId, XldRowsM, XldColsM, XldPointCountsM, ModelRow, ModelColumn, ModelAngle, ModelScale, ModelScore)</l>
<l>    if (|ModelScore|&gt;0)</l>
<l>        detect_line (Image, RowSource, ColumnSource, AngleSource, ModelRow, ModelColumn, ModelAngle, RowRectLeft1, ColRectLeft1, RowRectLeft2, ColRectLeft2, 30, 'vertical', 3, 20, 'positive', 'last', LineLeftRow1, LineLeftCol1, LineLeftRow2, LineLeftCol2)</l>
<l>        detect_line (Image, RowSource, ColumnSource, AngleSource, ModelRow, ModelColumn, ModelAngle, RowRectUp1, ColRectUp1, RowRectUp2, ColRectUp2, 30, 'horizontal', 3, 20, 'positive', 'last', LineUpRow1, LineUpCol1, LineUpRow2, LineUpCol2)</l>
<c></c>
<l>        detect_circle (Image, PartCircleXLD1, Regions1, Cross1, Circle1, RowSource, ColumnSource, AngleSource, ModelRow, ModelColumn, ModelAngle, RowCircle1, ColCircle1, RadiusCircle1, 0, 360, 50, 20, 6, 1, 20, 'positive', 'last', 'outer', 10, 'circle', RowCenter1, ColCenter1, Radius1)</l>
<l>        detect_circle (Image, PartCircleXLD2, Regions2, Cross2, Circle2, RowSource, ColumnSource, AngleSource, ModelRow, ModelColumn, ModelAngle, RowCircle2, ColCircle2, RadiusCircle2, 0, 360, 50, 20, 6, 1, 20, 'positive', 'last', 'outer', 10, 'circle', RowCenter2, ColCenter2, Radius2)</l>
<c></c>
<l>        intersection_lines (LineLeftRow1, LineLeftCol1, LineLeftRow2, LineLeftCol2, LineUpRow1, LineUpCol1, LineUpRow2, LineUpCol2, RowCross, ColCross, IsOverlapping)</l>
<l>        tuple_atan2 (LineLeftRow2-LineLeftRow1, LineLeftCol2-LineLeftCol1, Phi)</l>
<l>        angle := Phi*180.0/3.1415926</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_set_color ('green')</l>
<l>        dev_set_draw ('margin')</l>
<l>        dev_set_line_width (1)</l>
<l>        dev_display (Image)</l>
<l>*         image_points_to_world_plane (CameraParameters, CameraPose, RowCenter1, ColCenter1, 'mm', RowCenter1, ColCenter1)</l>
<l>*         image_points_to_world_plane (CameraParameters, CameraPose, RowCenter2, ColCenter2, 'mm', RowCenter2, ColCenter2)</l>
<l>*         image_points_to_world_plane (CameraParameters, CameraPose, RowCross, ColCross, 'mm', RowCross, ColCross)</l>
<l>*         image_points_to_world_plane (CameraParameters, CameraPose, ModelRow, ModelColumn, 'mm', ModelRow, ModelColumn)</l>
<c>        </c>
<c>        </c>
<l>        gen_region_points (RegionPoint1, RowCenter1, ColCenter1)</l>
<l>        gen_region_points (RegionPoint2, RowCenter2, ColCenter2)</l>
<l>        distance_pp (RowCross, ColCross, RowCenter1, ColCenter1, DistanceCrossCircle)</l>
<l>        distance_pp (RowCross, ColCross, ModelRow, ModelColumn, DistanceCrossModel)</l>
<l>        distance_pp (RowCenter1, ColCenter1, ModelRow, ModelColumn, DistanceCircleModel)</l>
<l>        distance_pp (RowCenter1, ColCenter1, RowCenter2, ColCenter2, DistanceCircleCircle)</l>
<c>        </c>
<l>        disp_line (WindowHandle, LineLeftRow1, LineLeftCol1, LineLeftRow2, LineLeftCol2)</l>
<l>        disp_line (WindowHandle, LineUpRow1, LineUpCol1, LineUpRow2, LineUpCol2)</l>
<l>        dev_display (Regions1)</l>
<l>        dev_display (Regions2)</l>
<l>        dev_set_color ('red')</l>
<l>        dev_set_line_width (1)</l>
<l>        dev_display (Cross1)</l>
<l>        dev_display (RegionPoint1)</l>
<l>        dev_display (Circle1)</l>
<l>        dev_display (Cross2)</l>
<l>        dev_display (RegionPoint2)</l>
<l>        dev_display (Circle2)</l>
<l>        disp_cross (WindowHandle, RowCross, ColCross, 50, 0)</l>
<c>        </c>
<l>        disp_message (WindowHandle, 'Cross &amp; Circle Distance: ' + DistanceCrossCircle, 'window', 12, 12, 'black', 'true')</l>
<l>        disp_message (WindowHandle, 'Cross &amp; Model  Distance: ' + DistanceCrossModel, 'window', 32, 12, 'black', 'true')</l>
<l>        disp_message (WindowHandle, 'Model &amp; Circle Distance: ' + DistanceCircleModel, 'window', 52, 12, 'black', 'true')</l>
<l>        disp_message (WindowHandle, 'C1    &amp; C2     Distance: ' + DistanceCircleCircle, 'window', 72, 12, 'black', 'true')</l>
<l>        stop ()</l>
<l>    endif</l>
<l>endfor</l>
<l>stop ()</l>
<l>stop ()</l>
<l>stop ()</l>
<c></c>
<c></c>
<l>cout := |ModelAngle|</l>
<c></c>
<l>gen_cross_contour_xld (Cross2, ModelRow, ModelColumn, 16, 0.6)</l>
<l>p2 := XldPointCountsM</l>
<l>add := 0</l>
<c></c>
<l>gen_empty_obj (XldsModel2)</l>
<l>for i := 0 to |p2| -1 by 1</l>
<l>    gen_contour_polygon_xld (Contour, XldRowsM[add :add + p2[i]-1], XldColsM[add:add + p2[i]-1])</l>
<l>    add := add + p2[i]</l>
<l>    concat_obj (XldsModel2, Contour, XldsModel2)</l>
<l>endfor</l>
<c as_id="matching" as_name="Matching 01" as_grp="[11]" as_ord="1"></c>
<l as_id="matching" as_name="Matching 01" as_grp="[11]" as_ord="2">clear_shape_model (ModelId)</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="CreateFeatureModel">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Rows" base_type="ctrl" dimension="0"/>
<par name="Columns" base_type="ctrl" dimension="0"/>
<par name="NumLevels" base_type="ctrl" dimension="0"/>
<par name="AngleStart" base_type="ctrl" dimension="0"/>
<par name="AngleExtent" base_type="ctrl" dimension="0"/>
<par name="AngleStep" base_type="ctrl" dimension="0"/>
<par name="ScaleMin" base_type="ctrl" dimension="0"/>
<par name="ScaleMax" base_type="ctrl" dimension="0"/>
<par name="MinContrast" base_type="ctrl" dimension="0"/>
<par name="MaxContrast" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelId" base_type="ctrl" dimension="0"/>
<par name="RowSource" base_type="ctrl" dimension="0"/>
<par name="ColumnSource" base_type="ctrl" dimension="0"/>
<par name="AngleSource" base_type="ctrl" dimension="0"/>
<par name="XldRows" base_type="ctrl" dimension="0"/>
<par name="XldCols" base_type="ctrl" dimension="0"/>
<par name="XldPointCounts" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>AngleExtentOut := AngleExtent</l>
<l>AngleStartOut := AngleStart</l>
<l>AngleStepOut := AngleStep</l>
<l>AngleStartOut := rad(AngleStartOut)</l>
<l>AngleExtentOut := rad(AngleExtentOut)</l>
<l>AngleStepOut := rad(AngleStepOut)</l>
<c></c>
<l>gen_region_polygon_filled (Region, Rows, Columns)</l>
<l>reduce_domain (Image, Region, TemplateImage)</l>
<l>set_system ('border_shape_models', 'false')</l>
<c as_id="matching" as_name="Matching 01" as_grp="[1,1,4]" as_ord="1"></c>
<l as_id="matching" as_name="Matching 01" as_grp="[1,1,4]" as_ord="2">create_scaled_shape_model (TemplateImage, NumLevels, AngleStartOut, AngleExtentOut, AngleStepOut, ScaleMin, ScaleMax, 0.0121, ['none','no_pregeneration'], 'use_polarity', [MinContrast,MaxContrast,MinLength], 3, ModelId)</l>
<l>find_scaled_shape_model (TemplateImage, ModelId, AngleStartOut, AngleExtentOut, ScaleMin, ScaleMax, 0.5, 1, 0.5, 'least_squares', NumLevels, 0.9, RowSource, ColumnSource, AngleSource, Scale, Score)</l>
<c></c>
<l as_id="matching" as_name="Matching 01" as_grp="[1,2]" as_ord="2">get_shape_model_contours (ModelContours, ModelId, 1)</l>
<l>vector_angle_to_rigid (0, 0, 0, RowSource, ColumnSource, AngleSource, HomMat2D)</l>
<l>affine_trans_contour_xld (ModelContours, ModelContours, HomMat2D)</l>
<l>count_obj (ModelContours, Num)</l>
<c></c>
<l>XldRows := []</l>
<l>XldCols := []</l>
<l>XldPointCounts := []</l>
<c></c>
<l>for Index := 1 to Num by 1</l>
<l>    select_obj (ModelContours, ObjectSelected, Index)</l>
<l>    get_contour_xld (ObjectSelected, Rows, Cols)</l>
<l>    XldRows := [XldRows,Rows]</l>
<l>    XldCols := [XldCols,Cols]</l>
<l>    XldPointCounts := [XldPointCounts,|Rows|] </l>
<l>endfor</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="CreateFeatureModel">
<parameters>
<parameter id="AngleExtent"/>
<parameter id="AngleSource"/>
<parameter id="AngleStart"/>
<parameter id="AngleStep"/>
<parameter id="ColumnSource"/>
<parameter id="Columns"/>
<parameter id="Image"/>
<parameter id="MaxContrast"/>
<parameter id="MinContrast"/>
<parameter id="MinLength"/>
<parameter id="ModelId"/>
<parameter id="NumLevels"/>
<parameter id="RowSource"/>
<parameter id="Rows"/>
<parameter id="ScaleMax"/>
<parameter id="ScaleMin"/>
<parameter id="XldCols"/>
<parameter id="XldPointCounts"/>
<parameter id="XldRows"/>
</parameters>
</docu>
</procedure>
<procedure name="FindFeatureModel">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="AngleStart" base_type="ctrl" dimension="0"/>
<par name="AngleExtent" base_type="ctrl" dimension="0"/>
<par name="AngleStep" base_type="ctrl" dimension="0"/>
<par name="ScaleMin" base_type="ctrl" dimension="0"/>
<par name="ScaleMax" base_type="ctrl" dimension="0"/>
<par name="MinScore" base_type="ctrl" dimension="0"/>
<par name="NumMatches" base_type="ctrl" dimension="0"/>
<par name="ModelId" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XldRowsM" base_type="ctrl" dimension="0"/>
<par name="XldColsM" base_type="ctrl" dimension="0"/>
<par name="XldPointCountsM" base_type="ctrl" dimension="0"/>
<par name="ModelRow" base_type="ctrl" dimension="0"/>
<par name="ModelColumn" base_type="ctrl" dimension="0"/>
<par name="ModelAngle" base_type="ctrl" dimension="0"/>
<par name="ModelScale" base_type="ctrl" dimension="0"/>
<par name="ModelScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>AngleExtentOut := AngleExtent</l>
<l>AngleStartOut := AngleStart</l>
<l>AngleStepOut := AngleStep</l>
<l>AngleStartOut := rad(AngleStartOut)</l>
<l>AngleExtentOut := rad(AngleExtentOut)</l>
<l>AngleStepOut := rad(AngleStepOut)</l>
<l>XldRowsM := []</l>
<l>XldColsM := []</l>
<l>XldPointCountsM := []</l>
<l as_id="matching" as_name="Matching 01" as_grp="[6]" as_ord="2">find_scaled_shape_model (Image, ModelId, AngleStartOut, AngleExtentOut, ScaleMin, ScaleMax,MinScore, NumMatches, 0.5, 'least_squares', [5,1], 0.75, ModelRow, ModelColumn, ModelAngle, ModelScale, ModelScore)</l>
<l>get_shape_model_contours (ModelContours, ModelId, 1)</l>
<l as_id="matching" as_name="Matching 01" as_grp="[7,2]" as_ord="1">for MatchingObjIdx := 0 to |ModelScore| - 1 by 1</l>
<l as_id="matching" as_name="Matching 01" as_grp="[7,3]" as_ord="1">    hom_mat2d_identity (HomMat)</l>
<l as_id="matching" as_name="Matching 01" as_grp="[7,4]" as_ord="1">    hom_mat2d_scale (HomMat, ModelScale[MatchingObjIdx], ModelScale[MatchingObjIdx], 0, 0, HomMat)</l>
<l as_id="matching" as_name="Matching 01" as_grp="[7,5]" as_ord="1">    hom_mat2d_rotate (HomMat, ModelAngle[MatchingObjIdx], 0, 0, HomMat)</l>
<l as_id="matching" as_name="Matching 01" as_grp="[7,5]" as_ord="2">    hom_mat2d_translate (HomMat, ModelRow[MatchingObjIdx], ModelColumn[MatchingObjIdx], HomMat)</l>
<l as_id="matching" as_name="Matching 01" as_grp="[7,5]" as_ord="3">    affine_trans_contour_xld (ModelContours, TransContours, HomMat)</l>
<c>    </c>
<l>    count_obj (TransContours, Num)</l>
<l>    for Index := 1 to Num by 1</l>
<l>        select_obj (TransContours, ObjectSelected, Index)</l>
<l>        get_contour_xld (ObjectSelected, Rows, Cols)</l>
<l>        XldRowsM := [XldRowsM,Rows]</l>
<l>        XldColsM := [XldColsM,Cols]</l>
<l>        XldPointCountsM := [XldPointCountsM,|Rows|] </l>
<l>    endfor</l>
<c>    </c>
<l as_id="matching" as_name="Matching 01" as_grp="[7,7]" as_ord="1">endfor</l>
<l>return ()</l>
</body>
<docu id="FindFeatureModel">
<parameters>
<parameter id="AngleExtent"/>
<parameter id="AngleStart"/>
<parameter id="AngleStep"/>
<parameter id="Image"/>
<parameter id="MinScore"/>
<parameter id="ModelAngle"/>
<parameter id="ModelColumn"/>
<parameter id="ModelId"/>
<parameter id="ModelRow"/>
<parameter id="ModelScale"/>
<parameter id="ModelScore"/>
<parameter id="NumMatches"/>
<parameter id="ScaleMax"/>
<parameter id="ScaleMin"/>
<parameter id="XldColsM"/>
<parameter id="XldPointCountsM"/>
<parameter id="XldRowsM"/>
</parameters>
</docu>
</procedure>
<procedure name="detect_line">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="RowSource" base_type="ctrl" dimension="0"/>
<par name="ColSource" base_type="ctrl" dimension="0"/>
<par name="AngleSource" base_type="ctrl" dimension="0"/>
<par name="RowImage" base_type="ctrl" dimension="0"/>
<par name="ColImage" base_type="ctrl" dimension="0"/>
<par name="AngleImage" base_type="ctrl" dimension="0"/>
<par name="RectRow1" base_type="ctrl" dimension="0"/>
<par name="RectCol1" base_type="ctrl" dimension="0"/>
<par name="RectRow2" base_type="ctrl" dimension="0"/>
<par name="RectCol2" base_type="ctrl" dimension="0"/>
<par name="Step" base_type="ctrl" dimension="0"/>
<par name="Direction" base_type="ctrl" dimension="0"/>
<par name="Sigma" base_type="ctrl" dimension="0"/>
<par name="Threshold" base_type="ctrl" dimension="0"/>
<par name="Transition" base_type="ctrl" dimension="0"/>
<par name="Selection" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="LineRow1" base_type="ctrl" dimension="0"/>
<par name="LineCol1" base_type="ctrl" dimension="0"/>
<par name="LineRow2" base_type="ctrl" dimension="0"/>
<par name="LineCol2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***********************************************************</c>
<l>* dev_close_window ()</l>
<l>* dev_open_window (0, 0, 800, 800, 'black', WindowHandle)</l>
<c></c>
<l>try</l>
<c>* step1.</c>
<l>vector_angle_to_rigid (RowSource, ColSource, AngleSource, RowImage, ColImage, AngleImage, RevertHomMat2D)</l>
<l>vector_angle_to_rigid (RowImage, ColImage, AngleImage, RowSource, ColSource, AngleSource, HomMat2D)</l>
<l>affine_trans_image (Image, Image, HomMat2D, 'constant', 'false')</l>
<c>    </c>
<l>gen_rectangle1 (Rectangle1, RectRow1, RectCol1, RectRow2, RectCol2)</l>
<l>smallest_rectangle2 (Rectangle1, row0, col0, radius0, len01, len02)</l>
<l>phi0 := deg(radius0)</l>
<l>if(phi0 &lt; 0)</l>
<l>    phi0 := phi0 + 180</l>
<l>endif</l>
<l>radius0 := rad(phi0)</l>
<l>if('horizontal' == Direction)</l>
<l>    if(phi0 &lt; 90)</l>
<l>        phi1 := phi0 + 90</l>
<l>    else</l>
<l>        phi1 := phi0 - 90</l>
<l>    endif</l>
<l>elseif('vertical' == Direction)</l>
<l>    phi1 := phi0 - 90</l>
<l>endif</l>
<l>radius1 := rad(phi1)</l>
<c></c>
<c>* step2.</c>
<l>stepLen := len01 * 1.0 / Step</l>
<l>RowsEdge := []</l>
<l>ColsEdge := []</l>
<l>len1Meas := len02</l>
<l>len2Meas := 0.6 * stepLen</l>
<l>radiusMeas := radius1</l>
<l>get_image_size (Image, WidthImg, HeightImg)</l>
<l>for i := 0 to Step by 1</l>
<l>    rowMeas := row0 + (Step - 2 * i) * stepLen * sin(radius0)</l>
<l>    colMeas := col0 - (Step - 2 * i) * stepLen * cos(radius0)</l>
<l>    gen_rectangle2 (Rectangle, rowMeas, colMeas, radiusMeas, len1Meas, len2Meas)</l>
<l>    gen_measure_rectangle2 (rowMeas, colMeas, radiusMeas, len1Meas, len2Meas, \
                            WidthImg, HeightImg, 'nearest_neighbor', MeasureHandle)</l>
<l>    measure_pos (Image, MeasureHandle, \
                 Sigma, Threshold, Transition, Selection, \
                 RowEdgePoint, ColEdgePoint, Amp, Dist)</l>
<l>    close_measure (MeasureHandle)</l>
<l>    if(|Amp| &gt; 0)</l>
<l>        indices := 0</l>
<l>        tuple_abs (Amp, Amp)</l>
<l>        tuple_max (Amp, tempMax)</l>
<l>        tuple_find (Amp, tempMax, indices)</l>
<l>        RowsEdge := [RowsEdge, RowEdgePoint[indices[0]]]</l>
<l>        ColsEdge := [ColsEdge, ColEdgePoint[indices[0]]]</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>* step3.</c>
<l>if(|RowsEdge| &gt; (Step * 0.5))</l>
<l>    gen_contour_polygon_xld (lineXLD, RowsEdge, ColsEdge)</l>
<l>    fit_line_contour_xld (lineXLD, 'tukey', -1, 0, 5, 2, \
                          LineRow1, LineCol1, LineRow2, LineCol2, Nr, Nc, Dist1)</l>
<l>    affine_trans_point_2d (RevertHomMat2D, LineRow1, LineCol1, LineRow1, LineCol1)</l>
<l>    affine_trans_point_2d (RevertHomMat2D, LineRow2, LineCol2, LineRow2, LineCol2)</l>
<l>    image_point_in_world (LineRow1, LineCol1, LineRow1, LineCol1)</l>
<l>    image_point_in_world (LineRow2, LineCol2, LineRow2, LineCol2)</l>
<l>endif</l>
<l>catch (Exception)</l>
<l>*     log_exception (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="detect_line">
<parameters>
<parameter id="AngleImage">
<sem_type>real</sem_type>
</parameter>
<parameter id="AngleSource">
<sem_type>real</sem_type>
</parameter>
<parameter id="ColImage">
<sem_type>real</sem_type>
</parameter>
<parameter id="ColSource">
<sem_type>real</sem_type>
</parameter>
<parameter id="Direction">
<default_value>'vertical'</default_value>
<sem_type>string</sem_type>
<value_list>
<item>'vertical'</item>
<item>'horizontal'</item>
</value_list>
</parameter>
<parameter id="Image">
<sem_type>image</sem_type>
</parameter>
<parameter id="LineCol1">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="LineCol2">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="LineRow1">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="LineRow2">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RectCol1">
<sem_type>real</sem_type>
</parameter>
<parameter id="RectCol2">
<sem_type>real</sem_type>
</parameter>
<parameter id="RectRow1">
<sem_type>real</sem_type>
</parameter>
<parameter id="RectRow2">
<sem_type>real</sem_type>
</parameter>
<parameter id="RowImage">
<sem_type>real</sem_type>
</parameter>
<parameter id="RowSource">
<sem_type>real</sem_type>
</parameter>
<parameter id="Selection">
<default_type>string</default_type>
<default_value>'all'</default_value>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'first'</item>
<item>'last'</item>
<item>'all'</item>
</value_list>
</parameter>
<parameter id="Sigma">
<default_type>real</default_type>
<default_value>3.0</default_value>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Step">
<default_type>integer</default_type>
<default_value>30</default_value>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>100</value_max>
<value_min>10</value_min>
</parameter>
<parameter id="Threshold">
<default_type>integer</default_type>
<default_value>20</default_value>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Transition">
<default_type>string</default_type>
<default_value>'all'</default_value>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'positive'</item>
<item>'negative'</item>
<item>'all'</item>
</value_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="list_image_files">
<interface>
<ic>
<par name="ImageDirectory" base_type="ctrl" dimension="0"/>
<par name="Extensions" base_type="ctrl" dimension="0"/>
<par name="Options" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure returns all files in a given directory</c>
<c>* with one of the suffixes specified in Extensions.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* ImageDirectory: as the name says</c>
<c>*    If a tuple of directories is given, only the images in the first</c>
<c>*    existing directory are returned.</c>
<c>*    If a local directory is not found, the directory is searched</c>
<c>*    under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,</c>
<c>*    %HALCONROOT%/images is used instead.</c>
<c>* Extensions: A string tuple containing the extensions to be found</c>
<c>*    e.g. ['png','tif',jpg'] or others</c>
<c>* If Extensions is set to 'default' or the empty string '',</c>
<c>*    all image suffixes supported by HALCON are used.</c>
<c>* Options: as in the operator list_files, except that the 'files'</c>
<c>*    option is always used. Note that the 'directories' option</c>
<c>*    has no effect but increases runtime, because only files are</c>
<c>*    returned.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageFiles: A tuple of all found image file names</c>
<c>* </c>
<l>if (Extensions == [] or Extensions == '' or Extensions == 'default')</l>
<l>    Extensions := ['ima','tif','tiff','gif','bmp','jpg','jpeg','jp2','jxr','png','pcx','ras','xwd','pbm','pnm','pgm','ppm']</l>
<c>    * </c>
<l>endif</l>
<l>if (ImageDirectory == '')</l>
<l>    ImageDirectory := '.'</l>
<l>endif</l>
<l>get_system ('image_dir', HalconImages)</l>
<l>get_system ('operating_system', OS)</l>
<l>if (OS{0:2} == 'Win')</l>
<l>    HalconImages := split(HalconImages,';')</l>
<l>else</l>
<l>    HalconImages := split(HalconImages,':')</l>
<l>endif</l>
<l>Directories := ImageDirectory</l>
<l>for Index := 0 to |HalconImages| - 1 by 1</l>
<l>    Directories := [Directories,HalconImages[Index] + '/' + ImageDirectory]</l>
<l>endfor</l>
<l>tuple_strlen (Directories, Length)</l>
<l>tuple_gen_const (|Length|, false, NetworkDrive)</l>
<l>if (OS{0:2} == 'Win')</l>
<l>    for Index := 0 to |Length| - 1 by 1</l>
<l>        if (strlen(Directories[Index]) &gt; 1)</l>
<l>            tuple_str_first_n (Directories[Index], 1, Substring)</l>
<l>            if (Substring == '//' or Substring == '\\\\')</l>
<l>                NetworkDrive[Index] := true</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<l>ImageFiles := []</l>
<l>for Index := 0 to |Directories| - 1 by 1</l>
<l>    file_exists (Directories[Index], FileExists)</l>
<l>    if (FileExists)</l>
<l>        list_files (Directories[Index], ['files',Options], AllFiles)</l>
<l>        ImageFiles := []</l>
<l>        for i := 0 to |Extensions| - 1 by 1</l>
<l>            tuple_regexp_select (AllFiles, ['.*' + Extensions[i] + '$','ignore_case'], Selection)</l>
<l>            ImageFiles := [ImageFiles,Selection]</l>
<l>        endfor</l>
<l>        tuple_regexp_replace (ImageFiles, ['\\\\','replace_all'], '/', ImageFiles)</l>
<l>        if (NetworkDrive[Index])</l>
<l>            tuple_regexp_replace (ImageFiles, ['//','replace_all'], '/', ImageFiles)</l>
<l>            ImageFiles := '/' + ImageFiles</l>
<l>        else</l>
<l>            tuple_regexp_replace (ImageFiles, ['//','replace_all'], '/', ImageFiles)</l>
<l>        endif</l>
<l>        return ()</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="list_image_files">
<abstract lang="en_US">This procedure returns all files in a given directory ImageDirectory with one of the suffixes specified in Extensions.

If a tuple of directories is given in ImageDirectory, only the images in the first existing directory are returned. If a local directory is not found, the directory is searched under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set, %HALCONROOT%/images is used instead.
If Extensions is set to 'default' or the empty string '', all image suffixes supported by HALCON are used.
The parameter Options is used as in the operator list_files (see list_files for details), except that the 'files' option is always used. Note that the 'directories' option has no effect but increases runtime, because only files are returned.</abstract>
<alternatives>
<item>list_files</item>
</alternatives>
<chapters>
<item>File</item>
</chapters>
<chapters lang="de_DE">
<item>Datei</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<chapters lang="zh_CN">
<item>File</item>
<item>Misc</item>
</chapters>
<example lang="en_US">list_image_files ('.',[] ,[] , ImageFiles)
for Index := 1 to |ImageFiles|  by 1
    read_image (Image,ImageFiles[Index-1])
*     do something
endfor</example>
<keywords lang="de_DE">
<item>Bilddateien auflisten</item>
</keywords>
<keywords lang="en_US">
<item>list image files</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>list_files</item>
</predecessor>
<see_also>
<item>list_files</item>
</see_also>
<short>Get all image files under the given path</short>
<short lang="de_DE">Get all image files under the given path</short>
<short lang="en_US">Get all image files under the given path</short>
<short lang="zh_CN">Get all image files under the given path</short>
<successor>
<item>read_image</item>
</successor>
<parameters>
<parameter id="Extensions">
<default_type>string</default_type>
<default_value>'default'</default_value>
<description lang="en_US">A string tuple containing the extensions to be found e.g. ['png','tif',jpg'] or others</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'ima'</item>
<item>'bmp'</item>
<item>'jpg'</item>
<item>'png'</item>
<item>'tiff'</item>
<item>'tif'</item>
<item>'gif'</item>
<item>'jpeg'</item>
<item>'pcx'</item>
<item>'pgm'</item>
<item>'ppm'</item>
<item>'pbm'</item>
<item>'xwd'</item>
<item>'pnm'</item>
</values>
</parameter>
<parameter id="ImageDirectory">
<default_type>string</default_type>
<description lang="en_US">The image directory</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">A tuple of all found image file names</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.read</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Options">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Processing options</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'recursive'</item>
<item>'follow_links'</item>
<item>'max_depth 5'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="two_line_cross">
<interface>
<ic>
<par name="Line1Row1" base_type="ctrl" dimension="0"/>
<par name="Line1Col1" base_type="ctrl" dimension="0"/>
<par name="Line1Row2" base_type="ctrl" dimension="0"/>
<par name="Line1Col2" base_type="ctrl" dimension="0"/>
<par name="Line2Row1" base_type="ctrl" dimension="0"/>
<par name="Line2Col1" base_type="ctrl" dimension="0"/>
<par name="Line2Row2" base_type="ctrl" dimension="0"/>
<par name="Line2Col2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PointX" base_type="ctrl" dimension="0"/>
<par name="PointY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_cross_contour_xld (Cross, Line1Row1, Line1Row1, 6, 0.785398)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="two_line_cross">
<parameters>
<parameter id="Line1Col1">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Line1Col2">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Line1Row1">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Line1Row2">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Line2Col1">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Line2Col2">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Line2Row1">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Line2Row2">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PointX">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PointY">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="detect_circle">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PartCircleXLD" base_type="iconic" dimension="0"/>
<par name="Regions" base_type="iconic" dimension="0"/>
<par name="Cross" base_type="iconic" dimension="0"/>
<par name="Circle" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="RowSource" base_type="ctrl" dimension="0"/>
<par name="ColSource" base_type="ctrl" dimension="0"/>
<par name="AngleSource" base_type="ctrl" dimension="0"/>
<par name="RowImage" base_type="ctrl" dimension="0"/>
<par name="ColImage" base_type="ctrl" dimension="0"/>
<par name="AngleImage" base_type="ctrl" dimension="0"/>
<par name="DrawRow" base_type="ctrl" dimension="0"/>
<par name="DrawCol" base_type="ctrl" dimension="0"/>
<par name="DrawRadius" base_type="ctrl" dimension="0"/>
<par name="StartAngle" base_type="ctrl" dimension="0"/>
<par name="EndAngle" base_type="ctrl" dimension="0"/>
<par name="Elements" base_type="ctrl" dimension="0"/>
<par name="DetectHeight" base_type="ctrl" dimension="0"/>
<par name="DetectWidth" base_type="ctrl" dimension="0"/>
<par name="Sigma" base_type="ctrl" dimension="0"/>
<par name="Threshold" base_type="ctrl" dimension="0"/>
<par name="Transition" base_type="ctrl" dimension="0"/>
<par name="Select" base_type="ctrl" dimension="0"/>
<par name="Direct" base_type="ctrl" dimension="0"/>
<par name="crossSize" base_type="ctrl" dimension="0"/>
<par name="RealArcType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowCenter" base_type="ctrl" dimension="0"/>
<par name="ColCenter" base_type="ctrl" dimension="0"/>
<par name="Radius" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (PartCircleXLD)</l>
<l>gen_empty_obj (Cross)</l>
<l>gen_empty_obj (Circle)</l>
<l>gen_empty_obj (Regions)</l>
<c>  </c>
<l>try </l>
<l>vector_angle_to_rigid (RowSource, ColSource, AngleSource, RowImage, ColImage, AngleImage, RevertHomMat2D)</l>
<l>vector_angle_to_rigid (RowImage, ColImage, AngleImage, RowSource, ColSource, AngleSource, HomMat2D)</l>
<l>affine_trans_image (Image, Image, HomMat2D, 'constant', 'false')</l>
<c></c>
<l>gen_circle_contour_xld (PartCircleXLD, DrawRow, DrawCol, DrawRadius, rad(StartAngle), rad(EndAngle), 'positive', 1)</l>
<l>get_contour_xld (PartCircleXLD, SourceRow, SourceCol)</l>
<l>spoke (Image, Regions, Elements, DetectHeight, DetectWidth, Sigma, Threshold, Transition, Select, SourceRow, SourceCol, Direct, ResultRow, ResultColumn, ArcType)</l>
<l>gen_cross_contour_xld (Cross, ResultRow, ResultColumn, crossSize, 0.785398)</l>
<c></c>
<c>*通过上面两段圆弧上的过渡点，根据点集合[ResultRow, ResultColumn]拟合出最合适的圆Circle </c>
<c>*该圆的信息为：RowCenter, ColCenter, Radius</c>
<l>pts_to_best_circle (Circle, [ResultRow], [ResultColumn], int(|ResultRow|*0.8), RealArcType, RowCenter, ColCenter, Radius)</l>
<c></c>
<c></c>
<l>affine_trans_contour_xld (PartCircleXLD, PartCircleXLD, RevertHomMat2D)</l>
<l>affine_trans_contour_xld (Cross, Cross, RevertHomMat2D)</l>
<l>affine_trans_contour_xld (Circle, Circle, RevertHomMat2D)</l>
<l>* union1 (RegionVec, Regions)</l>
<l>affine_trans_region (Regions, Regions, RevertHomMat2D, 'nearest_neighbor')</l>
<l>affine_trans_point_2d (RevertHomMat2D, RowCenter, ColCenter, RowCenter, ColCenter)</l>
<l>image_point_in_world (RowCenter, ColCenter, RowCenter, ColCenter)</l>
<l>catch (Exception)</l>
<l>*     log_exception (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="detect_circle">
<predecessor>
<item>gen_circle</item>
</predecessor>
<parameters>
<parameter id="AngleImage">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="AngleSource">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Circle">
<sem_type>xld</sem_type>
</parameter>
<parameter id="ColCenter">
<default_type>real</default_type>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ColImage">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ColSource">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cross">
<sem_type>xld</sem_type>
</parameter>
<parameter id="DetectHeight">
<default_type>integer</default_type>
<default_value>100</default_value>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DetectWidth">
<default_type>integer</default_type>
<default_value>20</default_value>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Direct">
<default_type>string</default_type>
<default_value>'outer'</default_value>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'outer'</item>
<item>'inner'</item>
</values>
</parameter>
<parameter id="DrawCol">
<default_type>real</default_type>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DrawRadius">
<default_type>real</default_type>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DrawRow">
<default_type>real</default_type>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Elements">
<default_type>integer</default_type>
<default_value>30</default_value>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EndAngle">
<default_type>integer</default_type>
<default_value>360</default_value>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image">
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="PartCircleXLD">
<multivalue>false</multivalue>
<sem_type>xld</sem_type>
</parameter>
<parameter id="Radius">
<default_type>real</default_type>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RealArcType">
<default_type>string</default_type>
<default_value>'circle'</default_value>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'circle'</item>
<item>'arc'</item>
</values>
</parameter>
<parameter id="Regions">
<sem_type>region</sem_type>
</parameter>
<parameter id="RowCenter">
<default_type>real</default_type>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowImage">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowSource">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Select">
<default_type>string</default_type>
<default_value>'first'</default_value>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'first'</item>
<item>'last'</item>
<item>'max'</item>
</values>
</parameter>
<parameter id="Sigma">
<default_type>real</default_type>
<default_value>1.0</default_value>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="StartAngle">
<default_type>integer</default_type>
<default_value>0</default_value>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Threshold">
<default_type>integer</default_type>
<default_value>20</default_value>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Transition">
<default_type>string</default_type>
<default_value>'positive'</default_value>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'negative'</item>
<item>'positive'</item>
<item>'all'</item>
</values>
</parameter>
<parameter id="crossSize">
<default_type>integer</default_type>
<default_value>10</default_value>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="spoke">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Regions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Elements" base_type="ctrl" dimension="0"/>
<par name="DetectHeight" base_type="ctrl" dimension="0"/>
<par name="DetectWidth" base_type="ctrl" dimension="0"/>
<par name="Sigma" base_type="ctrl" dimension="0"/>
<par name="Threshold" base_type="ctrl" dimension="0"/>
<par name="Transition" base_type="ctrl" dimension="0"/>
<par name="Select" base_type="ctrl" dimension="0"/>
<par name="ROIRows" base_type="ctrl" dimension="0"/>
<par name="ROICols" base_type="ctrl" dimension="0"/>
<par name="Direct" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ResultRow" base_type="ctrl" dimension="0"/>
<par name="ResultColumn" base_type="ctrl" dimension="0"/>
<par name="ArcType" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>	get_image_size(Image,Width,Height)</l>
<c>	 </c>
<l>	gen_empty_obj(Regions)</l>
<l>ResultRow := []</l>
<l>ResultColumn := []</l>
<c> </c>
<c> </c>
<l>gen_contour_polygon_xld(Contour, ROIRows, ROICols)</l>
<c> </c>
<l>fit_circle_contour_xld (Contour, 'algebraic', -1, 0, 0, 3, 2, RowC, ColumnC, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>gen_circle_contour_xld (ContCircle, RowC, ColumnC, Radius, StartPhi, EndPhi, PointOrder, 3)</l>
<l>get_contour_xld (ContCircle, RowXLD, ColXLD)</l>
<c> </c>
<l>length_xld(ContCircle, Length)</l>
<l>tuple_length(ColXLD, Length2)</l>
<l>if(Elements&lt;1)</l>
<c> </c>
<l>   return()</l>
<l>endif  </l>
<l>for i := 0 to Elements-1 by 1</l>
<l>    if(RowXLD[0]=RowXLD[Length2-1])</l>
<l>       tuple_int(1.0*Length2/(Elements-1)*(i), j)</l>
<l>       ArcType:='circle'</l>
<l>    else</l>
<l>          tuple_int(1.0*Length2/(Elements-1)*(i), j)</l>
<l>         ArcType:='arc'  </l>
<l>    endif</l>
<l>     if(j&gt;=Length2)</l>
<l>            j:=Length2-1</l>
<l>*             continue</l>
<l>     endif</l>
<l>    RowE:=RowXLD[j]</l>
<l>    ColE:=ColXLD[j] </l>
<c>    </c>
<c>    *超出图像区域，不检测，否则容易报异常</c>
<l>    if (RowE&gt;Height-1 or RowE&lt;0 or ColE&gt;Width-1 or ColE&lt;0)</l>
<l>		continue </l>
<l>    endif</l>
<l>    if(Direct='inner')</l>
<l>         tuple_atan2(-RowE+RowC, ColE-ColumnC, ATan)</l>
<l>         ATan:=rad(180)+ATan</l>
<c>        </c>
<l>    else</l>
<l>    tuple_atan2(-RowE+RowC, ColE-ColumnC, ATan)</l>
<c>      </c>
<l>    endif</l>
<c>   </c>
<c>   </c>
<l>    gen_rectangle2(Rectangle1, RowE,  ColE, ATan, DetectHeight/2, DetectWidth/2)</l>
<l>    concat_obj(Regions, Rectangle1, Regions)</l>
<l>    if(i=0)</l>
<l>        RowL2:=RowE+DetectHeight/2*sin(-ATan)</l>
<l>        RowL1:=RowE-DetectHeight/2*sin(-ATan)</l>
<l>        ColL2:=ColE+DetectHeight/2*cos(-ATan)</l>
<l>        ColL1:=ColE-DetectHeight/2*cos(-ATan)</l>
<l>        gen_arrow_contour_xld (Arrow1, RowL1, ColL1, RowL2, ColL2, 25, 25)</l>
<l>        gen_region_contour_xld (Arrow1, Arrow1Region, 'margin')</l>
<l>        concat_obj (Regions, Arrow1Region, Regions)</l>
<l>      endif</l>
<c></c>
<l>		gen_measure_rectangle2(RowE, ColE, ATan, DetectHeight/2,DetectWidth/2,Width, Height, 'nearest_neighbor', MsrHandle_Measure)</l>
<c>	 </c>
<c>		 </c>
<l>		if (Transition = 'negative')</l>
<l>            Transition := 'negative'</l>
<l>        else </l>
<l>          if (Transition = 'positive')</l>
<c>		 </c>
<l>			Transition := 'positive'</l>
<l>     	  else  </l>
<l>            Transition := 'all'</l>
<l>          endif</l>
<l>       endif</l>
<c>   </c>
<l>		if (Select = 'first')</l>
<l>            Select := 'first'</l>
<l>        else </l>
<l>          if (Select = 'last')</l>
<c>		 </c>
<l>			Select := 'last'</l>
<l>     	  else  </l>
<l>            Select := 'all'</l>
<l>          endif</l>
<l>       endif</l>
<c>	</c>
<l>    measure_pos (Image, MsrHandle_Measure, Sigma, Threshold, Transition, Select, RowEdge, ColEdge, Amplitude, Distance)</l>
<l>		close_measure(MsrHandle_Measure)</l>
<l>		tRow := 0</l>
<l>		tCol := 0</l>
<l>		t:= 0</l>
<l>    tuple_length(RowEdge, Number)</l>
<l>    if(Number&lt;1)</l>
<l>        continue</l>
<l>    endif</l>
<l>		for k:=0 to Number-1 by 1</l>
<l>		    if(abs(Amplitude[k])&gt;t)</l>
<c>			 </c>
<l>            tRow := RowEdge[k]</l>
<l>				tCol := ColEdge[k]</l>
<l>				t := abs(Amplitude[k])</l>
<l>			endif</l>
<l>       endfor</l>
<l>		if(t&gt;0)</l>
<c>		 </c>
<l>			ResultRow:=[ResultRow,tRow]</l>
<l>			ResultColumn:=[ResultColumn,tCol]</l>
<l>		endif</l>
<l>  endfor</l>
<c>   </c>
<c>  </c>
<l>return ()</l>
</body>
<docu id="spoke">
<library lang="zh_CN">MVTec Standard Procedures</library>
<parameters>
<parameter id="ArcType">
<default_type>string</default_type>
<description lang="zh_CN">拟合圆弧类型：'arc'圆弧；'circle'圆</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'circle'</item>
<item>'arc'</item>
</values>
</parameter>
<parameter id="DetectHeight">
<default_type>integer</default_type>
<default_value>60</default_value>
<description lang="zh_CN">卡尺工具的高度</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>30</item>
<item>60</item>
<item>90</item>
<item>120</item>
</values>
</parameter>
<parameter id="DetectWidth">
<default_type>integer</default_type>
<default_value>15</default_value>
<description lang="zh_CN">卡尺工具的宽度</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>5</item>
<item>10</item>
<item>15</item>
<item>20</item>
<item>25</item>
<item>30</item>
</values>
</parameter>
<parameter id="Direct">
<default_type>string</default_type>
<default_value>'inner'</default_value>
<description lang="zh_CN">'inner'表示检测方向由边缘点指向圆心;
'outer'表示检测方向由圆心指向边缘点</description>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'inner'</item>
<item>'outer'</item>
</values>
</parameter>
<parameter id="Elements">
<default_type>integer</default_type>
<default_value>30</default_value>
<description lang="zh_CN">检测边缘点数</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_list>
<item>1</item>
<item>5</item>
<item>10</item>
<item>20</item>
<item>30</item>
</value_list>
<value_max>100000</value_max>
<value_min>1</value_min>
</parameter>
<parameter id="Image">
<description lang="zh_CN">输入图像</description>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="ROICols">
<default_type>real</default_type>
<description lang="zh_CN">检测区域起点的x值</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ROIRows">
<default_type>real</default_type>
<description lang="zh_CN">检测区域起点的y值</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Regions">
<description lang="zh_CN">输出边缘点检测区域及方向</description>
<sem_type>object</sem_type>
</parameter>
<parameter id="ResultColumn">
<default_type>real</default_type>
<description lang="zh_CN">检测到的边缘点的x坐标数组</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
<values>
<item>ResultColumn</item>
</values>
</parameter>
<parameter id="ResultRow">
<description lang="zh_CN">检测到的边缘点的y坐标数组</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>ResultRow</item>
</values>
</parameter>
<parameter id="Select">
<default_type>string</default_type>
<default_value>'max'</default_value>
<description lang="zh_CN">first表示选择第一点
last表示选择最后一点
max表示选择边缘强度最强点</description>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'first'</item>
<item>'last'</item>
<item>'max'</item>
</values>
</parameter>
<parameter id="Sigma">
<default_type>real</default_type>
<default_value>1</default_value>
<description lang="zh_CN">高斯滤波因子</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
<values>
<item>0.5</item>
<item>1</item>
<item>1.5</item>
<item>2</item>
<item>2.5</item>
<item>3</item>
</values>
</parameter>
<parameter id="Threshold">
<default_value>20</default_value>
<description lang="zh_CN">边缘检测阈值，又叫边缘强度</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>5</item>
<item>10</item>
<item>15</item>
<item>20</item>
<item>25</item>
<item>30</item>
<item>40</item>
</values>
</parameter>
<parameter id="Transition">
<default_type>string</default_type>
<default_value>'all'</default_value>
<description lang="zh_CN">极性：
positive表示由黑到白
negative表示由白到黑
all表示以上两种方向</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'positive'</item>
<item>'negative'</item>
<item>'all'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="pts_to_best_circle">
<interface>
<oo>
<par name="Circle" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Rows" base_type="ctrl" dimension="0"/>
<par name="Cols" base_type="ctrl" dimension="0"/>
<par name="ActiveNum" base_type="ctrl" dimension="0"/>
<par name="ArcType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowCenter" base_type="ctrl" dimension="0"/>
<par name="ColCenter" base_type="ctrl" dimension="0"/>
<par name="Radius" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>RowCenter := 0</l>
<l>ColCenter := 0</l>
<l>Radius := 0</l>
<c></c>
<l>gen_empty_obj (Circle)</l>
<l>tuple_length(Cols, Length)</l>
<c></c>
<l>	if (Length&gt;=ActiveNum and ActiveNum&gt;2)</l>
<c>	</c>
<l>		gen_contour_polygon_xld(Contour, Rows, Cols)</l>
<l>        fit_circle_contour_xld (Contour, 'geotukey', -1, 0, 0, 3, 2, RowCenter, ColCenter, Radius, StartPhi, EndPhi, PointOrder)</l>
<c>		 </c>
<l>        tuple_length(StartPhi, Length1)</l>
<l>        if(Length1&lt;1)</l>
<l>           return()</l>
<l>        endif</l>
<l>        if(ArcType='arc')</l>
<l>            gen_circle_contour_xld(Circle, RowCenter, ColCenter, Radius, StartPhi, EndPhi, PointOrder, 1)</l>
<l>        else</l>
<l>            gen_circle_contour_xld(Circle, RowCenter, ColCenter, Radius, 0, rad(360), PointOrder, 1)</l>
<l>        endif</l>
<l>	endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="pts_to_best_circle">
<parameters>
<parameter id="ActiveNum">
<description lang="zh_CN">最小有效点数</description>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArcType">
<default_type>string</default_type>
<default_value>'circle'</default_value>
<description lang="zh_CN">拟合圆弧类型：'arc'圆弧；'circle'圆</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'circle'</item>
<item>'arc'</item>
</values>
</parameter>
<parameter id="Circle">
<description lang="zh_CN">输出拟合圆的xld</description>
<sem_type>xld</sem_type>
</parameter>
<parameter id="ColCenter">
<description lang="zh_CN">拟合的圆中心x</description>
<sem_type>real</sem_type>
</parameter>
<parameter id="Cols">
<description lang="zh_CN">拟合圆的输入x数组</description>
<sem_type>real</sem_type>
</parameter>
<parameter id="Radius">
<description lang="zh_CN">拟合的圆半径</description>
<sem_type>real</sem_type>
</parameter>
<parameter id="RowCenter">
<description lang="zh_CN">拟合的圆中心y</description>
<sem_type>real</sem_type>
</parameter>
<parameter id="Rows">
<description lang="zh_CN">拟合圆的输入y数组</description>
<sem_type>real</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="image_point_in_world">
<interface>
<ic>
<par name="ImageRow" base_type="ctrl" dimension="0"/>
<par name="ImageCol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WorldRow" base_type="ctrl" dimension="0"/>
<par name="WorldCol" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c as_id="calibration" as_name="Calibration 03" as_grp="[1,1]" as_ord="1">* Calibration 03: Code generated by Calibration 03</c>
<l as_id="calibration" as_name="Calibration 03" as_grp="[2,1]" as_ord="1">CameraParameters := [0.0361311,-255.17,17.3289,264.664,3.46549e-006,3.45e-006,1263.53,982.218,2448,2048]</l>
<l as_id="calibration" as_name="Calibration 03" as_grp="[2,2]" as_ord="1">CameraPose := [-0.00497858,0.0012356,0.41697,358.34,344.276,359.933,0]</l>
<c></c>
<l>* CameraParameters := ['area_scan_tilt_division',0.0354652,-229.021,0.0210793,9.12259,188.047,3.51938e-006,3.45e-006,1223.88,1023.86,2448,2048]</l>
<l>* CameraPose := [-0.00359841,-0.000400561,0.401512,344.84,359.377,0.0830362,0]</l>
<l>image_points_to_world_plane (CameraParameters, CameraPose, ImageRow, ImageCol, 'mm', WorldRow, WorldCol)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="image_point_in_world">
<parameters>
<parameter id="ImageCol">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageRow">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WorldCol">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WorldRow">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
</hdevelop>
